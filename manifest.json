{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"JUnit version 4.11-SNAPSHOT-20120416-1530\n.\nTime: 0.177\n\nOK (1 test)\n\n","instructions":"Java Functional Programming by Jessica Kerr\n\ntype safe\n\nfunctional programming with java\n  C24C65, tuna, fpwj-original\n  4DAE5E, starfish, fpwj-functionsAsValues\n  BDA089, snake, fpwj-functionsReturningFunctions\n  D96026, salmon, fpwj-typeSafe\n","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n    @Test\n    public void should_calculate_total_profits_for_the_year_in_FunctionOverTime() {\n        // given\n        final double[] EXPECTED_SALES_JAN_TO_DEC =\n            new double[] { 42.0, 45.6, 43.6, 50.2, 55.6, 54.7,\n                    58.0, 57.3, 62.0, 60.3, 71.2, 88.8};\n        final Sales sales = new Sales(\n                FunctionOverTime.monthByMonth(EXPECTED_SALES_JAN_TO_DEC));\n\n        final FixedCosts fixedCosts = new FixedCosts(\n                FunctionOverTime.constant(15.0));\n\n        final IncrementalCosts incrementalCosts =\n                new IncrementalCosts(\n                FunctionOverTime.line(5.1, 0.15));\n\n        final Profit profit =\n                new Profit(\n                        sales,\n                        incrementalCosts,\n                        fixedCosts);\n\n        // when\n        Double totalProfits = 0.0;\n        for(int time = 1; time <= 12; time ++) {\n            totalProfits += profit.valueAt(time);\n        }\n\n        // then\n        assertEquals(436.4, totalProfits, 0.001);\n    }\n\n}\n","FixedCosts.java":"\npublic class FixedCosts implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public FixedCosts(FunctionOverTime valueFunction) {\n        this.valueFunction = valueFunction;\n    }\n\n    public String getName() {\n        return \"Fixed Costs\";\n    }\n\n    public double valueAt(int time) {\n        return valueFunction.valueAt(time);\n    }\n}\n","FunctionOverTime.java":"\n@FunctionalInterface\npublic interface FunctionOverTime {\n\n    double valueAt(int time);\n\n    static FunctionOverTime monthByMonth(final double[] values) {\n        return (time) -> values[time - 1];\n    }\n\n    static FunctionOverTime constant(final double constantValue) {\n        return polynomial(new double[] { constantValue });\n    }\n\n    static FunctionOverTime line(final double intercept, final double slope) {\n        return polynomial(new double[] { intercept, slope });\n    }\n\n    static FunctionOverTime polynomial(final double[] coefficients) {\n        return (time) -> {\n            Double sum = 0.0;\n            for (int i = 0; i < coefficients.length; i++) {\n                sum += Math.pow(time, i) * coefficients[i];\n            }\n            return sum;\n        };\n    }\n\n    @FunctionalInterface\n    public static interface FunctionOf3 {\n        public double apply(double a, double b, double c);\n    }\n\n    static FunctionOverTime combinationOf3(final FunctionOverTime a,\n                                            final FunctionOverTime b,\n                                            final FunctionOverTime c,\n                                            final FunctionOf3 combination) {\n        return (time) -> combination.apply(a.valueAt(time),\n                b.valueAt(time),\n                c.valueAt(time));\n    }\n}\n","IncrementalCosts.java":"\npublic class IncrementalCosts implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public IncrementalCosts(FunctionOverTime valueFunction) {\n        this.valueFunction = valueFunction;\n    }\n\n    public String getName() {\n        return \"Incremental Costs\";\n    }\n\n    public double valueAt(int time) {\n        return valueFunction.valueAt(time);\n    }\n}\n","Profit.java":"public class Profit implements QuantityOfInterest {\n    private final Sales sales;\n    private final IncrementalCosts incrementalCosts;\n    private final FixedCosts fixedCosts;\n\n    public Profit(Sales s, IncrementalCosts ic, FixedCosts fc) {\n        this.sales = s;\n        this.incrementalCosts = ic;\n        this.fixedCosts = fc;\n    }\n\n    public String getName() {\n        return \"Profit!!\";\n    }\n\n    public double valueAt(int time) {\n        return sales.valueAt(time) -\n                (incrementalCosts.valueAt(time) +\n                fixedCosts.valueAt(time));\n    }\n\n}\n","QuantityOfInterest.java":"\npublic interface QuantityOfInterest {\n\n    String getName();\n\n    /**\n     * expected value for a particular month\n     * @param time month, 1-12\n     * @return expected value\n     */\n    double valueAt(final int time);\n}","Sales.java":"\npublic class Sales implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public Sales(FunctionOverTime valueFunction) {\n        this.valueFunction = valueFunction;\n    }\n\n    public String getName() {\n        return \"Sales\";\n    }\n\n    public double valueAt(int time) {\n        return valueFunction.valueAt(time);\n    }\n}\n"}